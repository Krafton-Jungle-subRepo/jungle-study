# 시작하며
---

- 정글 1~2주차 알고리즘 / 자료구조 내용 간략하게 핵심만 잡으면서 Review

- 알고리즘 문제풀이에 대한 팁

  - 정확한 개념의 중요성 → 핵심 개념에서 추가되지도, 빠지지도 않아야 함

  - 개념의 활용 방법

- 나도 틀릴수 있음~~

- 문제풀이 방법이나 코드 구현, 수학적 증명은 생략(나도 몰라요)


# 알고리즘 문제풀이
---

- 알고리즘 문제풀이란?

```
+----------------------------+
|       Implementation       | -+
+----------------------------+  |
|            Idea            |  | Problem solving!!
+----------------------------+  |
| Algorithm | Data structure | -+
+----------------------------+
```

## 문제가 풀리지 않는 이유?

### 1. 풀이 방법이 떠오르지 않아요(발상)

- 알고리즘 / 문제풀이 방법 자체를 모를 경우

- 풀이 방법(발상이 잘 떠오르지 않는 경우)

```
                    +--+
+---------+      +--+  +---+
|         |    +-+         ++
| concept | -> |   concept ++
|         |    +-+         |
+---------+      +------+  +
                        |  |
                        +__+

+---------+      +--+  +---+
|         |      |  +--+   +-+
| concept | ---> ++concept +-+
|         |       +     +--+
+---------+       +-----+
```

- 필요 개념보다 더 복잡하게 인식하고 있는 경우 (개념이 정확하게 잡히지 않은 경우 1)

- 개념을 잘못 알고 있는 경우 (개념이 정확하게 잡히지 않은 경우 2)

  - 개념의 뼈대가 되는 부분을 정확히 인식하는것이 중요

  - 개념간의 규칙성과 패턴을 찾는 것이 중요

    → 개념을 key word를 포함, 일반화하여 단순하고 간단하게 설명할 수 있어야

- 개념간의 연결이 되지 않는 경우
 
  - ex) 2차원 matrix와 graph

- 발상: 알고리즘 / 자료구조를 어떻게 활용할 것인가? → 정확한 개념 + 경험


### 2. 어떻게 풀지는 알겠는데 코드로 못쓰겠어요(구현)

- 구현능력 → 구현 언어에 대한 이해 + 구현 경험

  - python `x in list`와 `x in dictionary` / python3과 pypy (메모리와 시간의 반비례)

  - ex) C style python code

- 추상적이고 고차원적인 절차를 단순하고 1차원적인 절차로 분해(컴퓨팅 사고력)


## 문제에 어떻게 접근할 것인가?

- 발상 → 풀이방법 검증 → 구현 → 문제 해결!

- 풀이방법 검증 방법 → 시간복잡도, 공간복잡도

- 공간복잡도는 어지간하면 안터진다 → 터지면 무한루프, 무한재귀 가능성이 높음


### 시간복잡도

- 점근 표기법 Big-O

- 시간복잡도의 종류

  - $O(1)$: 상수 시간

  - $O(\log_k n)$: 로그 시간: 단계가 지날 때마다 n이 k로 나누어 지는 경우 (이진탐색, 트리)

  - $O(n)$: 선형 시간: 반복문

  - $O(n\log n)$: 선형로그 시간: 로그 시간을 n번 반복하는 경우 (퀵 소트)

  - $O(n^k)$: 제곱 시간: k차 matrix 순회

  - $O(k^n)$, $O(n!)$: 지수 시간, 팩토리얼 시간 (permutation)

  - example. 시간복잡도 계산해보기
```python
# l = sorted m length list
for num in range(n):
	if num in l:
		binary_search(l, num)
```
: $O(nm\log m)$

- 일반적으로 $O(1억)$을 1초로 계산

- 문제를 풀 때 항상 input의 범위와 제한 시간 확인 필요

- 프로그램 성능의 척도가 될 수 있음음


# 개념의 정리
---

- 추상적 표현과 구현된 형상(편의상 이렇게 부름)의 구분 필요 ex) priority queue와 heap

- **추상적 표현** → 고차원적인 프로그래밍을 위한 Interface 제공 ex) 정렬, 우선순위 큐

- **구현된 형상** → 추상적 표현을 실제로 사용할 수 있도록 코드로 구현해 놓은 것

- 추상적 표현과 구현된 형상은 완전히 나뉘지 않을 수 있음 → 많이 헷갈리는 이유 2

  -  ex) priority queue와 heap, python의 heapq

- **개념 공부, 이해보다 개념이 무엇인지에 대한 인식이 선행되어야 함**

- 알고리즘 문제폴이 = 명확한 개념의 이해 + 발상 + 구현능력


# ADT와 자료구조
---

- ADT란? Abstract Data Structure(추상적 자료구조) → 추상적 표현

  - 이런게 있으면 쓸만하겠는데? 하고 머릿속에서 생각해본 것

- ADT의 구체적인 작동 방법을 명시한 것을 자료구조라 함 → 구현된 형상(Implementation)

- 자료구조를 ADT와 Algorithm 사이 어딘가로 생각할 수 있음

- ADT와 자료구조의 이름은 일치할수도, 아닐수도 있음 → 많이 헷갈리는 이유 2

  - ex) ADT stack과 C++의 stack


## Heap
---

- parent는 child보다 항상 우선순위가 높음 / 완전이진트리

- element 삽입은 마지막 node로 → 위로 올라가며 조정

- element 삭제는 root node에서 → 마지막 node를 root로 올린 후 내려가며 조정

- 시간복잡도는?


# 완전탐색
---

- 완전탐색이란? 모든 경우의 수를 전부 확인하는 방법(BruteForce)

  → graph에서의 완전탐색을 기준으로 설명

## Graph 완전탐색

```
+-- Graph --+      +-- Data Structure --+      +-- visited node --+
|           |      |                    |      |                  |
|           | ---> |                    | ---> |                  |
|           |      |                    |      |                  |
+-----------+      +--------------------+      +------------------+
```

1. 규칙에 따라 Node를 Data Structure로 옮긴다

  - 규칙: 방문한 node에서 갈 수 있는 모든 node를 Data Structure에 옮긴다.

2. Data Structure에서 node를 꺼내 방문한다

- DFS란? 더 깊은 곳을 먼저 탐색하는 것 (stack의 개념 없음)

- BFS란? 현재 노드에서 가까운 노드들을 먼저 탐색하는 것 (queue 개념 없음)

  - 완전탐색에서 Data Structure를 stack / queue를 썼더니 DFS / BFS 처럼 작동하더라 (o)

  - 백준 1388번 바닥장식을 반복문으로 풀었다? → 이것도 DFS라고 볼수 있다!

- 그래프 순회??


# 위상정렬(Topological Sorting)
---

- 위상정렬이란? 1) DAG(Directed Acyclic Graph)에 대해, 2) arc의 방향이 역전되지 않도록 3) 모든 node를 순서대로 정렬하는 것

  - ex) 수업 선수과목

- "모든" node를 정렬? → 이거 완전탐색이랑 비슷한데??

## 위상정렬 알고리즘

```
+-- Graph --+      +-- Data Structure --+      +-- Sorted Node --+
|           |      |                    |      |                 |
|           | ---> |                    | ---> |                 |
|           |      |                    |      |                 |
+-----------+      +--------------------+      +-----------------+
```

- indegree / outdegree: 어떤 노드로 들어오는 / 나가는 arc의 수

1. 규칙에 따라 node를 Data Structure에서 하나씩 꺼내어 정렬

2. indegree가 0이 되는 node를 Data Structure에 추가

  - 규칙: node가 정렬될 때, 그 node에서 시작하는 arc를 끊음(indegree 감소)


# 최소 신장 트리(Minimum Spanning Tree)
---

## 신장 트리(Spanning Tree)

- 무방향 그래프 내 모든 node를 포함하면서 cycle은 없는 그래프

- 하나의 그래프 내 많은 신장 트리가 있을 수 있음

- MST? 신장 트리를 구성하는 모든 edge의 weight의 합이 최소가 되는 신장 트리

## MST 구성 알고리즘

- 기본 발상: edge를 Data Structure에서 cycle이 발생하지 않도록 작은 것부터 꺼내옴

```
+-- Graph --+      +-- Data Structure --+      +-- Selected edge --+
|           |      |                    |      |                   |
|           | ---> |                    | ---> |                   |
|           |      |                    |      |                   |
+-----------+      +--------------------+      +-------------------+
```

- 어디서 꺼내올 것인가??

  - 모든 edge의 집합에서 → Kruskal Algorithm

  - 지금까지 구성된 MST와 연결된 edge의 집합에서 → Prim's Algorithm

- cycle 확인하는 방법 → Union & Find


# 최단거리 알고리즘
---

- 단일 출발점 최단경로: Bellman-Ford, Dijkstra

- 모든 쌍 최단경로: Floyd-Warshall → 인접 행렬 형식의 결과물 생성

- 음수 cycle이 있는 경우엔?

## 단일 출발점 최단경로 알고리즘

### Dijkstra

1. 현재 node에서 갈 수 있는 node들에 대해 최단거리 갱신

2. 방문하지 않은 node 중 가장 짧은 거리로 갈 수 있는 node 선택

- 음의 가중치가 있는 경우엔 어떻게 되는거지?

- 시간복잡도는? → 구현 방법에 따라 다름

### Bellman-Ford

1. 시작 node에서 i번째 방문할 수 있는 모든 node에 대해 최단거리 갱신

2. 1을 $V - 1$번 반복

- 음의 cycle을 가지고 있는 경우엔?

- 시간복잡도는?

## 모든 쌍 최단경로 알고리즘

### Floyd-Warshall

- $D_{ij} = min(D_{ij}, D_{ik} + D_{kj})$ (Dynamic Programming 기법)

- 모든 node에 대해 중간점, 시작점, 끝점을 순회하며 최단거리 업데이트


# B-Tree
---

- 2진 트리의 일반화

- 규칙을 지키면서, 삽입과 삭제 모두 leaf node에서 이루어짐 → 규칙이 깨질 경우 조정

  규칙 1. child의 수 = parent의 key 수 + 1 → 부모 key를 내리고 형제와 합친다

  규칙 2. key 수 < B → 머리를 쪼개고 올린다.


끝! 정글 7기 화이팅입니다 :)

작성자 정글 7기 최주혁
